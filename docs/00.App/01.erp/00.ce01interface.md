---
nav: en
title: ERP EJB Interfaces
date: 2024-01-09 12:12:46
permalink: /pages/1dfab2/
meta:
  - name: description
    content: Learning in ERP EJB Interfaces for ERP system. Browse reference, sample code, tutorials, and more.
  - name: keywords
    content: ERP EJB Interfaces, ERP, ERP software, ERP system, ERP solution
---

`Version: 1.2 | Release Date: 07/02/2024`

## MassMailHandler

### Purpose

It is used to handle email when sending email by [Mass Email of Documents].

<br/>

### Function handleEmail

```java
	public default void handleEmail(MacEmail email, SqlTable massmail, CawReport report, CawReportDataSet dataSet) {
	}
```

**Description**

It is used to handle email when sending email by [Mass Email of Documents].

**Parameters**

| Name     | Type               | Description                              |
| -------- | ------------------ | ---------------------------------------- |
| email    | `MacEmail`         | The email                                |
| massmail | `SqlTable`         | The main table of [Mass Email of Documents] |
| report   | `CawReport`        | CawReport                                |
| dataSet  | `CawReportDataSet` | CawReportDataSet                         |

<br/>

------

### Function sendEmail

```java
	public default Set<MacEmail> sendEmail(SqlTable massmail, CawReport report, CawReportDataSet dataSet, Map<Long, String> fileKey, Map<String, String> fileMap) {
		return null;
	}
```

**Description**

It is used to get more email address when sending email by [Mass Email of Documents].

Eg:  Core App can get the email addresses from cus/ven/staff/cnDept/virDept.

Eg:  Ac App can get the email addresses from Debtor/Creditor.

**Parameters**

| Name     | Type                  | Description                              |
| -------- | --------------------- | ---------------------------------------- |
| massmail | `SqlTable`            | The main table of [Mass Email of Documents] |
| report   | `CawReport`           | CawReport                                |
| dataSet  | `CawReportDataSet`    | CawReportDataSet                         |
| fileKey  | `Map<Long, String>`   | The preview file key-value pairs. `key` is the transaction id while `value` is the file name. |
| fileMap  | `Map<String, String>` | The preview file path key-value pairs. `key` is the file name while `value` is file path. |

**Result**

| Type            | Description            |
| --------------- | ---------------------- |
| `Set<MacEmail>` | Extra email addresses. |

<br/>

<br/>

## UpdateFrozenDate

### Purpose

It is used when developers want to interact with aiM18 when frozen date is ready to update or updated.

<br/>

### Function beforeUpdateFrozen

```java
	public default String beforeUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {
		return "";
	}
```

**Description**

Trigger before updating frozen date.

**Parameters**

| Name         | Type   | Description            |
| ------------ | ------ | ---------------------- |
| beId         | `Long` | The business entity id |
| frozenTypeId | `Long` | The forzen type id     |
| frozenDate   | `Date` | The frozen date        |

**Result**

| Type     | Description                           |
| -------- | ------------------------------------- |
| `String` | The `messCode` to describe the error. |

**Example**

```java
	@Override
	public String beforeUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {
		SqlTable data = MacCheckerUtil.excuteQuery("frozentype", " id = " + frozenTypeId);
		if (data != null && data.size() > 0) {
			SqlTable beFile = MacUtil.getBeGlobalSetting(beId);
			if (beFile != null && beFile.size() > 0) {
				if (frozenDate.before((Date) beFile.getValue(1, "stkClosed"))) {
					return "ce01_core.frozenPeriodSTKError";
				}
			}
		}
		return "";
	}
```

<br/>

------

### Function afterUpdateFrozen

```java
	public default void afterUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {

	}
```

**Description**

Trigger after updated the frozen date.

**Parameters**

| Name         | Type   | Description            |
| ------------ | ------ | ---------------------- |
| beId         | `Long` | The business entity id |
| frozenTypeId | `Long` | The frozen type id     |
| frozenDate   | `Date` | The frozen date        |

<br/>

<br/>

## ErpServerInitialized

### Purpose

This interface will be triggered after the database is updated and before the JBoss started completely.

It is usually used to initialize the cache or prepare default data.

<br/>

### Function contextInitialized

```java
	public default void contextInitialized() {

	}
```

**Description**

Trigger when the database is updated and before the JBoss started completely.

<br/>

------

### Function afterInitialized

```java
	public default void afterInitialized() {

	}
```

**Description**

Triggered after `contextInitialized()`.

<br/>

<br/>

## GenerateRecord

### Purpose

Used to interact with aiM18 when the system tried to create a record from another module. (Example: Delivery note generate Sales Invoice record)

<br/>

### Function beforeSaveRecord

```java
	public default boolean beforeSaveRecord(SqlEntity fromEntity, SqlEntity entity, String jsonParam) {
		return true;
	}
```

**Description**

Trigger when the target entity(e.g. Sales Invoice) is ready to save. Return `false` if developers need to prohibit the save process.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| fromEntity | `SqlEntity` | The entity of from module. Example: Entity of Delivery Note. |
| entity     | `SqlEntity` | The entity of to module. Example: Entity of Sales Invoice. |
| jsonParam  | `String`    | Some parameters.                         |

**Result**

| Type      | Description                           |
| --------- | ------------------------------------- |
| `boolean` | If `false`, recode will not be saved. |

<br/>

<br/>

## SpecBsRuleItem

### Purpose

Used to interact with aiM18 when business rule is needed in the system.

<br/>

### Function getSpecBsRuleItem

```java
	public default List<BsRuleItem> getSpecBsRuleItem(Long beId, String moduleName) {
		return null;
	}
```

**Description**

Triggered when aiM18 request for business rule items. Developers can define additional business rule in Java and return to the system. 

**Parameters**

| Name       | Type     | Description                    |
| ---------- | -------- | ------------------------------ |
| beId       | `Long`   | The current business entity id |
| moduleName | `String` | The triggered module's name    |

**Result**

| Type               | Description                              |
| ------------------ | ---------------------------------------- |
| `List<BsRuleItem>` | A list of additional business rule Items. |

**Example**

```java
public class TrdgSpecBsRuleItem implements SpecBsRuleItem {

	@Override
	public List<BsRuleItem> getSpecBsRuleItem(Long beId, String moduleName) {
		if (!MacUtil.matchAppModule(moduleName, TradeStaticVar.appName)
				&& !TradeUtil.isTradingUdfEditor(moduleName)) {
			return null;
		}
		List<BsRuleItem> specItems = new ArrayList<BsRuleItem>();
		BsRule rules = (BsRule) CawCache.getObject(ErpStaticVar.bsRule, "xxxx");
		if (rules != null) {
			if (TradeUtil.isAllowNs(beId) && TradeUtil.checkInventoryModule(beId, moduleName)) {
				BsRuleItem allowNsItem = rules.getChkList().get("allowNs");
				specItems.add(allowNsItem);
			}
		}
		return specItems;
	}
}
```

<br/>

<br/>

## ASaveChkHandler

### Purpose

Used to interact with aiM18 when a transaction is saved. Usually used to check the foreign key constrain/data when saving a transaction with footer values. 

For example, If the currency id in sales order(SO) is not equal to the currency id in the delivery note stated in the SO footer. the sales order cannot be saved.

<br/>

### Function getASaveChkSql

```java
	public default String getASaveChkSql(ASaveChkItem item, String moduleName, SqlTable mainData, String chkValue, String joinkeycol) {
		return null;
	}
```

**Description**

Define a SQL which used to check if the above following example is valid:

If the currency id in sales order(SO) is not equal to the currency id in the delivery note stated in the SO footer. the sales order cannot be saved.

If the dataset returned by running the SQL is non-empty, the transaction cannot be saved and error will pop up. 

**Parameters**

| Name       | Type           | Description                     |
| ---------- | -------------- | ------------------------------- |
| item       | `ASaveChkItem` | The `ASaveChkItem` object       |
| moduleName | `String`       | The module name                 |
| mainData   | `SqlTable`     | The main table of saving record |
| chkValue   | `String`       | The value of check field        |
| joinkeycol | `String`       | The join key condition          |

**Result**

| Type     | Description   |
| -------- | ------------- |
| `String` | SQL statement |

<br/>

<br/>

## GeneratedEJBLot

### Purpose

Used to interact with aiM18 when lot number is ready to generate in EJB. 

<br/>

### Function originAccept

```java
	public boolean originAccept(String module);
```

**Description**

Triggered when the lot number is ready to generate. Used to determine if the current module should generate the lot number using this interface. 

**Parameters**

| Name   | Type     | Description |
| ------ | -------- | ----------- |
| module | `String` | Module name |

**Result**

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `boolean` | `true` to generate the lot number using generate() in this interface. `fales` to generate the lot number using aiM18 default method. |

<br/>

------

### Function generate

```java
	public String generate(final String module, final Long beId, final int rowIndex, final SqlTable footer, final String[] emptyField, final String lotField, final String proField);
```

**Description**

Triggered when `originAccept()` return `true`. It is used to generate the lot number.

**Parameters**

| Name       | Type       | Description                              |
| ---------- | ---------- | ---------------------------------------- |
| module     | `String`   | The module name                          |
| beId       | `Long`     | The business entity id                   |
| rowIndex   | `int`      | The row index of footer table            |
| footer     | `SqlTable` | The footer table                         |
| emptyField | `String[]` | Ignore the empty row according to the empty fields. |
| lotField   | `String`   | The lot number field                     |
| proField   | `String`   | The product field                        |

**Result**

| Type     | Description              |
| -------- | ------------------------ |
| `String` | The lot number generated |

<br/>

<br/>

## GeneratedJSFLot

### Purpose

It is used when lot number is ready to generate In JSF. Functions and methods are the same as `GeneratedEJBLot`, please refer to [GeneratedEJBLot](#generatedejblot) for more details.

<br/>

<br/>

## LoadTradeFooter

### Purpose

Triggered when loading footer data from origin and used to assign unit price and description fields in footer.

<br/>

### Function getMultiProPriceDesc

```java
	public default SqlTable getMultiProPriceDesc(String moduleName, Long beId, Long refId, Long virDeptId, String date, String upOrigin, String descOrigin, SqlTable footer, String[] proField, String jsonParam, SqlTable result) {
		return null;
	}
```

**Description**

Triggered after the system loaded the footer data from origin, developer can use this function to amend or override the result set.

**Parameters**

| Name       | Type       | Description                           |
| ---------- | ---------- | ------------------------------------- |
| module     | `String`   | The module name                       |
| beId       | `Long`     | The business entity id                |
| refId      | `Long`     | The customer/vendor id                |
| virDeptId  | `Long`     | The business unit id                  |
| date       | `String`   | The date of the transaction           |
| upOrigin   | `String`   | Product price origin                  |
| descOrigin | `String`   | Product description origin            |
| footer     | `SqlTable` | The footer table instance             |
| proField   | `String[]` | String[] { "proId", "unitId", "qty" } |
| jsonParam  | `String`   | Some parameters                       |
| result     | `SqlTable` | The result table                      |

**Result**

| Type       | Description                              |
| ---------- | ---------------------------------------- |
| `SqlTable` | Return a sqlTable with amended result set. |

<br/>

------

### Function assign_footer_updesc

```java
	public default void assign_footer_updesc(SqlTable footer, int footerIndex, SqlTable tarTable, int rec) {

	}
```

**Description**

Triggered after the system assigned brief description and detail description or unit price. Developers can amended the final version of the fields' value before display it in the user interface.

**Parameters**

| Name        | Type       | Description                              |
| ----------- | ---------- | ---------------------------------------- |
| footer      | `SqlTable` | The footer table                         |
| footerIndex | `int`      | The row index of footer table            |
| tarTable    | `SqlTable` | The result table for assigning unit price or assigning different description. |
| rec         | `int`      | The row index of result table            |

<br/>

<br/>

## AssignLotnoHelper

### Purpose

It is used for developer to interact with aiM18 to amended the lot number table after the system has generate the default setting.

<br/>

### Function isAccept

```java
	public boolean isAccept();
```

**Description**

Determine if the other function in this interface should be run.

**Result**

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `boolean` | `true` to run other function in this interface. `false` to ignore this interface. |

<br/>

------

### Function getAssignLotno

```java
	public SqlTable getAssignLotno(long beId, String module, SqlTable stock);
```

**Description**

Trigger when aiM18 has generated lot number for the product. Developers can make use of this function to amend the lot number assigned in `stock`.

**Parameters**

| Name   | Type       | Description                            |
| ------ | ---------- | -------------------------------------- |
| beId   | `long`     | The business entity id                 |
| module | `String`   | The module name                        |
| stock  | `SqlTable` | The original assigned lot number table |

**Result**

| Type       | Description                    |
| ---------- | ------------------------------ |
| `SqlTable` | New assigned lot number table. |

<br/>

------

### Function sortStock

```java
	public void sortStock(String module, SqlTable stock, List<String> sortFieldList, List<Boolean> sortTypeList);
```

**Description**

Trigger right after `getAssignLotno()`. Used to sort the lot number table.

**Parameters**

| Name          | Type            | Description                              |
| ------------- | --------------- | ---------------------------------------- |
| module        | `String`        | The module name                          |
| stock         | `SqlTable`      | The lot number table                     |
| sortFieldList | `List<String>`  | A list of sorting fields.                |
| sortTypeList  | `List<Boolean>` | A list of sorting direction. The order of the direction mapped with the list of field list.  `true` means ascending. `false` means descending. |

<br/>

------

### Function isStockFit

```java
	public boolean isStockFit(String module, SqlTable stock, int stockIndex, SqlTable footer, int footerIndex);
```

**Description**

Determine if the lot number should be assigned.

**Parameters**

| Name        | Type       | Description                       |
| ----------- | ---------- | --------------------------------- |
| module      | `String`   | The module name                   |
| stock       | `SqlTable` | The lot number table              |
| stockIndex  | `int`      | The row index of lot number table |
| footer      | `SqlTable` | The footer table                  |
| footerIndex | `int`      | The row index of footer table     |

**Result**

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `boolean` | If `false`, the lot number will not assigned to footer table. |

<br/>

<br/>

## IMacCalcHandler

### Purpose

This interface is used for interacting with aiM18 using aiM18 Mobile Application.

<br/>

### Function getOrder

```java
	public int getOrder();
```

**Description**

Define the order of the interface, the lower the number, the earlier the interface will be called.

**Result**

| Type  | Description          |
| ----- | -------------------- |
| `int` | Return order number. |

<br/>

------

### Function efe_mainfooter_up

```java
	public void efe_mainfooter_up(long beId, String tranType, SqlTable footer, int rowIndex);
```

**Description**

Trigger when unit price is ready to be filled. 

**Parameters**

| Name     | Type       | Description                   |
| -------- | ---------- | ----------------------------- |
| beId     | `long`     | The business entity id        |
| tranType | `String`   | The module name               |
| footer   | `SqlTable` | The footer table              |
| rowIndex | `int`      | The row index of footer table |

<br/>

------

### Function calc_invamt

```java
	public default void calc_invamt(long beId, String tranType, SqlTable mainData, SqlTable mainFooter, SqlTable mainDisc) {
	}
```

**Description**

Used to calculate \<Total Amount / Total Charge / Total Discount / Amount> in header before the transaction saved.

**Parameters**

| Name       | Type       | Description            |
| ---------- | ---------- | ---------------------- |
| beId       | `long`     | The business entity id |
| tranType   | `String`   | The module name        |
| mainData   | `SqlTable` | The main table         |
| mainFooter | `SqlTable` | The footer table       |
| mainDisc   | `SqlTable` | The discount table     |

<br/>

------

### Function getInChargeQtyField

```java
	public default String getInChargeQtyField() {
		return "qty";
	};
```

**Description**

It is used to get inChargeQty field name in footer table.

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | Return the inChargeQty field in footer table. |

<br/>

------

### Function getFooterUpField

```java
	public default String getFooterUpField() {
		return "up";
	}
```

**Description**

It is used to get unit price field name in footer table.

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | Return the unit price field in footer table. |

<br/>

------

### Function getFooterUcField

```java
	public default String getFooterUcField() {
		return "uc";
	}
```

**Description**

It is used to get unit cost field name in footer table.

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | Return unit cost field name in footer table. |

<br/>

<br/>

## UpdateProCost

### Purpose

It is used for developer to interact with aiM18 when running Close Stock.

<br/>

### Detailed Description

```java
public interface UpdateProCost {

	/**
	 * For Product LLC
	 * this function can be replaced by using procedure named get_pro_llc_*
	 */
	public default SqlTable getMatList(Long beId, SqlTable varList) {
		return null;
	}

	/**
	 * For Data Updating(Stock In UC)
	 */
	public default void beforeLoadData(Long beId, SqlTable varList, SqlTable codeList) {

	}

	/**
	 * can append special field used in the getCalcUc
	 * or
	 * update data
	 */
	public default void afterLoadData(Long beId, SqlTable varList, SqlTable codeList, SqlTable stockIn, SqlTable stockOut, SqlTable stock_open) {

	}

	/**
	 * 1: return false(CalcUcStatus.skipOther) means skip the other instance of UpdateProCost
	 * 2: for special value please set it to CalcUcStatus.uc(and set CalcUcStatus.setUc = true)
	 */
	public default CalcUcStatus getCalcUc(String stk_mth, boolean isStockIn, int rowIndex, double calcUc, SqlTable tempVarList, SqlTable tempStockIn, SqlTable tempStockOut) {
		return null;
	}

	public default boolean calcFIFOUc(Long beId, SqlTable inVARLIST, Long proId, Date tranDate, int outIndex, SqlTable stockIn, SqlTable stockOut, SqlTable stock_open, SqlTable outAss, SqlTable retAss, SqlTable retUesd) {
		return false;
	}

	/**
	 * For Product Cost Updating(PC)
	 */
	public default void afterUpdateUc(Long beId, SqlTable varList, SqlTable codeList) {

	}

	/**
	 * For Data Updating After Close Stock
	 */
	public default void afterCloseStock(Long beId, SqlTable varList) {

	}

	/**
	 * For Data Updating After Reverse Stock
	 */
	public default void afterReverseStock(Long beId, SqlTable varList) {

	}
}
```

<br/>

<br/>

## LoadBomDataSourceHelper

### Purpose

For developer to adjust the bill of materials data after loading the instant cost sheet data.

<br/>

### Function updateBomDataSourceData

```java
	public List<SqlTable> updateBomDataSourceData(SqlEntity entity, int bomRec, int footerIndex, List<SqlTable> bomInfo, String bomDataSource);
```

**Description**

Trigger after the instant cost sheet data is loaded. 

**Parameters**

| Name          | Type             | Description                              |
| ------------- | ---------------- | ---------------------------------------- |
| entity        | `SqlEntity`      | The SqlEntity of the module              |
| bomRec        | `int`            | The row index of the bill of material list. |
| footerIndex   | `int`            | The row index of the main footer table.  |
| bomInfo       | `List<SqlTable>` | A group of `SqlTable`, use `bomInfo.get(0)` to get the table of bill of material list. |
| bomDataSource | `String`         | The data source.                         |

**Result**

| Type      | Description                   |
| --------- | ----------------------------- |
| `boolean` | Return the amended `bomInfo`. |

<br/>

<br/>

## ModuleSettingHelper

### Purpose

Determine the if the module should behave like that in stock module.

<br/>

### Function checkInventoryModule

```java
	public boolean checkInventoryModule(long beId, String moduleName);
```

**Description**

Determine if it is an inventory module. 

**Parameters**

| Name       | Type     | Description                    |
| ---------- | -------- | ------------------------------ |
| beId       | `long`   | The business entity id         |
| moduleName | `String` | The module name going to check |

**Result**

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `boolean` | if `true`, this module will act like an inventory module. |

<br/>

------

### Function getStkModule

```java
	public SqlTable getStkModule();
```

**Description**

Developer can define a module to be used in business flow process. 

**Result**

| Type       | Description                              |
| ---------- | ---------------------------------------- |
| `SqlTable` | A new `SqlTable` with one column(`module`) only. Provide the module name in every records to add additional module to the business flow process editor. |

<br/>

<br/>

## GenerateVoucher

### Purpose

For developers to interact with aiM18 when generating voucher from transactions.

<br/>

### Function getUDFOrder

```java
	public default int getUDFOrder(long beId, String moduleName, SqlEntity entity, boolean isStock) {
		return -1;
	}
```

**Description**

Determine if the function `GenerateUDFVoucher()` should be run. The number must be larger than `-1`. 

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module of the transaction            |
| entity     | `SqlEntity` | The `SqlEntity` of the transaction       |
| isStock    | `boolean`   | Indicate if the transaction is of stock transaction |

**Result**

| Type  | Description                              |
| ----- | ---------------------------------------- |
| `int` | The result integer should be larger than `-1` if `GenerateUDFVoucher()` needed to be run. |

<br/>

------

### Function GenerateUDFVoucher

```java
	public default Object GenerateUDFVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock) {
		return null;
	}
```

**Description**

Override the original system default voucher generation rules. Provide the new SQL to the system and generate a voucher. 

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module of the transaction            |
| entity     | `SqlEntity` | The `SqlEntity` of the transaction       |
| isStock    | `boolean`   | Indicate if the transaction is of stock transaction |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `Object` | Return `null` to ignore this function. Return `CheckMsg` object to prohibit the process to be completed, the transaction will be fail to save. Return `List<String>` which include all the SQL statements needed to generate the voucher. |

<br/>

------

### Function beforeGenerateVoucher

```java
	public String beforeGenerateVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**Description**

Trigger when `GenerateUDFVoucher()` return `null` and developers can provide additional SQL statements before the default SQL statements is generated.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module name going to check           |
| entity     | `SqlEntity` | The SqlEntity of the transaction         |
| isStock    | `boolean`   | Indicate if the transaction is stock related |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run before the SQL statement generated by the system is run. |

<br/>

------

### Function beforeGenT

```java
	public String beforeGenT(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**Description**

Trigger when `GenerateUDFVoucher()` return `null` and developers can provide additional SQL statements before the default SQL statements to generate the footer of the voucher is generated.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module name going to check           |
| entity     | `SqlEntity` | The SqlEntity of the transaction         |
| isStock    | `boolean`   | Indicate if the transaction is stock related |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run before the SQL statement generated by the system is run. |

<br/>

------

### Function afterGenerateVoucher

```java
	public String afterGenerateVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock, Long voucherId, boolean genModel);
```

**Description**

Trigger when `GenerateUDFVoucher()` return `null` and developers can provide additional SQL statements after all the default SQL statements of the voucher is generated.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module name going to check           |
| entity     | `SqlEntity` | The SqlEntity of the transaction         |
| isStock    | `boolean`   | Indicate if the transaction is stock related |
| voucherId  | `Long`      | The id of the voucher configuration editor |
| genModel   | `boolean`   | Indicate if the voucher is generated once the transaction is saved (Instant Voucher) |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run after the SQL statement generated by the system is run. |

<br/>

------

### Function afterGenerateInstanceVoucher

```java
	public String afterGenerateInstanceVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**Description**

Trigger after `afterGenerateVoucher()` and the voucher is generated once the transaction is saved (Instant Voucher).

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| beId       | `long`      | The business entity id                   |
| moduleName | `String`    | The module name going to check           |
| entity     | `SqlEntity` | The SqlEntity of the transaction         |
| isStock    | `boolean`   | Indicate if the transaction is stock related |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run after the SQL statement generated by the system is run. |

<br/>

------

### Function afterGenerateModuleVoucher

```java
	public String afterGenerateModuleVoucher(long beId, String moduleName, List<Long> ids, boolean isStock);
```

**Description**

Trigger when the voucher is batch generated per module and all the system default SQL statements is generated.

**Parameters**

| Name       | Type         | Description                              |
| ---------- | ------------ | ---------------------------------------- |
| beId       | `long`       | The business entity id                   |
| moduleName | `String`     | The module name going to check           |
| ids        | `List<Long>` | A group of transaction ids               |
| isStock    | `boolean`    | Determine if the transaction is stock type |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run after the SQL statement generated by the system is run. |

<br/>

------

### Function afterGenerateTranVoucher

```java
	public String afterGenerateTranVoucher(long beId, String moduleName, long ids, boolean isStock);
```

**Description**

Trigger when the voucher is batch generated per transaction and all the system default SQL statements is generated.

**Parameters**

| Name       | Type      | Description                              |
| ---------- | --------- | ---------------------------------------- |
| beId       | `long`    | The business entity id                   |
| moduleName | `String`  | The module name going to check           |
| ids        | `long`    | The transaction id                       |
| isStock    | `boolean` | Determine if the transaction is stock type |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run after the SQL statement generated by the system is run. |

<br/>

------

### Function afterBatchRevertVoucher

```java
	public String afterBatchRevertVoucher(long beId, long jlId);
```

**Description**

Trigger when the vouchers are ready to reverted and all the system default SQL statements is generated.

**Parameters**

| Name | Type   | Description                              |
| ---- | ------ | ---------------------------------------- |
| beId | `long` | The business entity id                   |
| jlId | `long` | The journal voucher's id that ready to be revert |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | The SQL statement that need to be run after the SQL statement generated by the system is run. |

<br/>

<br/>

## PrqAllocate

### Purpose

Interact with aiM18 when dealing with MRP Generation.

<br/>

### Function supply_demand

```java
	void supply_demand(long beId, SqlTable etdList, SqlTable etaList, SqlTable stkList, SqlTable etd_supply_List);
```

**Description**

Allocate the demand and supply quantity for special case in MRP generation.

**Parameters**

| Name            | Type       | Description                              |
| --------------- | ---------- | ---------------------------------------- |
| beId            | `long`     | The business entity id                   |
| etdList         | `SqlTable` | Demand list in step 2                    |
| etaList         | `SqlTable` | Supply list in step 2                    |
| stkList         | `SqlTable` | Supply stock quantity table              |
| etd_supply_List | `SqlTable` | The allocation result on [Available Quantity Setup]. |

<br/>

<br/>

## LoadLockTranHelper

### Purpose

Interact with aiM18 [Lock / Release Material] Editor.

<br/>

### Function addLoadLockTranCond

```java
	public void addLoadLockTranCond(long beId, String loadType, String module, List<FormatCond> conds);
```

**Description**

Trigger when loading matched material with/without lock. Developers can modify the user's conditions and affect the searching result.

**Parameters**

| Name     | Type               | Description                              |
| -------- | ------------------ | ---------------------------------------- |
| beId     | `long`             | The business entity id                   |
| loadType | `String`           | Determine if locked material should be loaded. Options: `lock`, `release` |
| module   | `String`           | The module that the system going to search |
| conds    | `List<FormatCond>` | The conditions defined by users          |



## TradingSettingHelper

### Purpose

Used to expand the [Preference Setup (Trade)] setting module.

<br/>

### Function `getLastTranTableName`

```java
	public default String getLastTranTableName(String origin) {
		return "";
	}
```

**Description**

Get the table name of the type of the "last transaction" source in the cache.

**Parameters**

| Name   | Type     | Description                    |
| ------ | -------- | ------------------------------ |
| origin | `String` | "Last transaction" source type |

**Result**

| Type     | Description                              |
| -------- | ---------------------------------------- |
| `String` | return the table name of the type of the "last transaction" source in the cache. |

------

### Function `addTradingSettingData`

```java
	public default void addTradingSettingData(Map<String, SqlTable> cacheMap) {
	}
```

**Description**

Add extra cached data for the `TradeStaticVar.tradingSetting` cache.

**Parameters**

| Name     | Type                    | Description                              |
| -------- | ----------------------- | ---------------------------------------- |
| cacheMap | `Map<String, SqlTable>` | `TradeStaticVar.tradingSetting` cache data |



## EcnHelper

### Purpose

Used to extend the [Engineering Change Note] module

<br/>

### Function `ecnChangeProcessExtraData`

```java
	public default void ecnChangeProcessExtraData(SqlEntity ecnpEntity, int ecnptRec, SqlEntity bomEntity, int bomptRec) {
	};
```

**Description**

Used for the [Engineering Change Note (Work Process)] module, the data added to the extension is replaced with the BOM change order.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| ecnpEntity | `SqlEntity` | The entity of [Engineering Change Note (Work Process)] |
| ecnptRec   | `int`       | The row index of [Engineering Change Note (Work Process)] footer table |
| bomEntity  | `SqlEntity` | The entity of [BOM]                      |
| bomptRec   | `int`       | The row index of [BOM] process footer    |



------

### Function `ecnChangeMatExtraData`

```java
	public default void ecnChangeMatExtraData(SqlEntity ecnmEntity, int ecnmtRec, SqlEntity bomEntity, int bomtRec) {
	};
```

**Description**

Used for the [Engineering Change Note (Material)] module, the data added to the extension is replaced with the BOM change order.

**Parameters**

| Name       | Type        | Description                              |
| ---------- | ----------- | ---------------------------------------- |
| ecnmEntity | `SqlEntity` | The entity of [Engineering Change Note (Material)] |
| ecnmtRec   | `int`       | The row index of [Engineering Change Note (Material)] footer table |
| bomEntity  | `SqlEntity` | The entity of [BOM]                      |
| bomtRec    | `int`       | The row index of [BOM] material footer   |



## DepositDataHelper

### Purpose

Used to extend deposit receivable and to receive/settle deposit.

<br/>

### Function  `appendArDepositReceipt`

```java
public default void appendArDepositReceipt(SqlTable retTable, long beId, long uId, String 			AIType, long AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean 	 loadGroupCo, String arapAlloType) {
}
```

**Description**

Used to load the extended deposit receipt/deposit utilised data, such as the deposit received in [POS Invoice]

**Parameters**

| 名称           | 类型         | 说明                                       |
| ------------ | ---------- | ---------------------------------------- |
| retTable     | `SqlTable` | Data of deposit receipt                  |
| beId         | `long`     | The business entity id                   |
| uId          | `long`     | User id                                  |
| AIType       | `String`   | Debtor Type                              |
| AIId         | `long`     | Debtor id                                |
| sourceId     | `long`     | The id of the transaction which load the data |
| tDate        | `String`   | As at date                               |
| orderList    | `String`   | The deposit list which need to load (load all when empty) |
| moduleFrom   | `String`   | The transaction type which load the data |
| loadGroupCo  | `boolean`  | Load group company data                  |
| arapAlloType | `String`   | The deposit type to read in [AR - AP Off-Set Slip] |



### **Example**

When a deposit receipt is load, you need to include the deposit received by [POS Invoice], as extended below

```java
@Override
public void appendArDepositReceipt(SqlTable retTable, long beId, long uId, String AIType, long   	AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean loadGroupCo, 	String arapAlloType) {
		String sql = "CALL l_poscoreac_recregdeposet (" + beId + ", " + uId + ", '" + AIType + 			"', " + AIId + ", " + sourceId + ", '" + tDate + "','" + orderList + "','" + moduleFrom 		+ "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### Function  `appendApDepositReceipt`

```java
public default void appendApDepositReceipt(SqlTable retTable, long beId, long uId, String 			AIType, long AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean 	 loadGroupCo, String arapAlloType) {
}
```

**Description**

Used to load the extended deposit payment/deposit utilised data, such as the deposit payment in [Subcontract Invoice]

**Parameters**

| 名称           | 类型         | 说明                                       |
| ------------ | ---------- | ---------------------------------------- |
| retTable     | `SqlTable` | Data of deposit payment                  |
| beId         | `long`     | The business entity id                   |
| uId          | `long`     | User id                                  |
| AIType       | `String`   | Creditor Type                            |
| AIId         | `long`     | Creditor id                              |
| sourceId     | `long`     | The id of the transaction which load the data |
| tDate        | `String`   | As at date                               |
| orderList    | `String`   | The deposit list which need to load (load all when empty) |
| moduleFrom   | `String`   | The transaction type which load the data |
| loadGroupCo  | `boolean`  | Load group company data                  |
| arapAlloType | `String`   | The deposit type to read in [AR - AP Off-Set Slip] |



### **Example**

When the deposit payment is load, the deposit used in [Subcontract Invoice] needs to be deducted as follows:

```java
@Override
public void appendApDepositReceipt(SqlTable retTable, long beId, long uId, String AIType, long 		AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean loadGroupCo, 	String arapAlloType) {
		String sql = "CALL l_pdcoreac_payregdeposet (" + beId + ", " + uId + ", '" + AIType + 			"', " + AIId + ", " + sourceId + ", '" + tDate + "','" + orderList + "','" + moduleFrom 		+ "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			Map<String, Double> depMap = new HashMap<>();
			Map<String, Double> depDomMap = new HashMap<>();

			int deci = MacUtil.getAmtDecimal(beId);
			for (int rec : myTable) {
				String sTranType = myTable.getValueStr(rec, "sTranType");
				long sTranId = myTable.getLong(rec, "sTranId");
				String refType = myTable.getValueStr(rec, "refType");
				long sorId = myTable.getLong(rec, "sorId");
				String lot = myTable.getValueStr(rec, "lot");

				String key = sTranType + StringLib.separate + sTranId + StringLib.separate + 					refType + StringLib.separate + sorId + StringLib.separate + lot;

				double depoAmt = myTable.getDouble(rec, "depoAmt");
				double domDepoAmt = myTable.getDouble(rec, "domDepoAmt");

				if (depMap.containsKey(key)) {
					depoAmt = MathLib.round(depoAmt + depMap.get(key), deci);
				}

				if (depDomMap.containsKey(key)) {
					domDepoAmt = MathLib.round(domDepoAmt + depDomMap.get(key), deci);
				}

				depMap.put(key, depoAmt);
				depDomMap.put(key, domDepoAmt);
			}

			List<Integer> recList = ListLib.newList();

			for (int rec : retTable) {
				String sTranType = retTable.getValueStr(rec, "sTranType");
				long sTranId = retTable.getLong(rec, "sTranId");
				String refType = retTable.getValueStr(rec, "refType");
				long sorId = retTable.getLong(rec, "sorId");
				String lot = retTable.getValueStr(rec, "lot");

				double bal = retTable.getDouble(rec, "bal");
				double balAmt = retTable.getDouble(rec, "balAmt");
				double balDomAmt = retTable.getDouble(rec, "balDomAmt");

				String key = sTranType + StringLib.separate + sTranId + StringLib.separate + 					refType + StringLib.separate + sorId + StringLib.separate + lot;

				if (depMap.containsKey(key)) {
					bal = MathLib.round(bal + depMap.get(key), deci);
					balAmt = MathLib.round(balAmt - depMap.get(key), deci);
				}

				if (depDomMap.containsKey(key)) {
					balDomAmt = MathLib.round(balDomAmt - depDomMap.get(key), deci);
				}

				retTable.setValue(rec, "bal", bal);
				retTable.setValue(rec, "balAmt", balAmt);
				retTable.setValue(rec, "balDomAmt", balDomAmt);

				if (balAmt <= 0) {
					recList.add(rec);
				}
			}

			if (recList.size() > 0) {
				retTable.deleteRows(recList);
			}
		}
}
```



------



### Function  `appendArOsDeposit`

```java
public default void appendArOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 	tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
}
```

**Description**

The data used to load extended deposit order, such as the deposit in a [Consignment Order]

**Parameters**

| 名称          | 类型         | 说明                                       |
| ----------- | ---------- | ---------------------------------------- |
| retTable    | `SqlTable` | Data of deposit                          |
| beId        | `long`     | The business entity id                   |
| uId         | `long`     | User id                                  |
| AIId        | `long`     | Debtor id                                |
| tranType    | `String`   | The transaction type which load the data |
| tranId      | `long`     | The id of the transaction which load the data |
| tDate       | `String`   | As at date                               |
| orderList   | `String`   | The deposit list which need to load (load all when empty) |
| loadGroupCo | `boolean`  | Load group company data                  |
| loadAll     | `boolean`  | Load with no balance                     |



### **Example**

When the deposit order is load, you need to add the deposit for the  [Consignment Order], which is extended below

```java
@Override
public void appendArOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 			tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
	String sql = "CALL l_consigncoamt2 (" + beId + ", " + uId + ", " + AIId + ", '" + tranType + 	 "', " + tranId + ", '" + tDate + "','" + orderList + "'," + (loadGroupCo ? 1 : 0) + "," + 		(loadAll ? 1 : 0) + ")";

	SqlTable myTable = CawDs.getResult(sql);
	if (myTable != null && myTable.size() > 0) {
		SqlTableLib.append(retTable, myTable);
	}
}
```



------



### Function  `appendApOsDeposit`

```java
public default void appendApOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 	tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
}
```

**Description**

The data used to load extended deposit order, such as the deposit in a [Subcontract Order]

**Parameters**

| 名称          | 类型         | 说明                                       |
| ----------- | ---------- | ---------------------------------------- |
| retTable    | `SqlTable` | Data of deposit                          |
| beId        | `long`     | The business entity id                   |
| uId         | `long`     | User id                                  |
| AIId        | `long`     | Creditor id                              |
| tranType    | `String`   | The transaction type which load the data |
| tranId      | `long`     | The id of the transaction which load the data |
| tDate       | `String`   | As at date                               |
| orderList   | `String`   | The deposit list which need to load (load all when empty) |
| loadGroupCo | `boolean`  | Load group company data                  |
| loadAll     | `boolean`  | Load with no balance                     |



### **Example**

When the deposit order is load, you need to add the deposit for the  [Subcontract Order], which is extended below

```java
@Override
public void appendApOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 			tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
	String sql = "CALL l_pdcoreac_amt (" + beId + ", " + uId + ", " + AIId + ", '" + tranType + 	"', " + tranId + ", '" + tDate + "','" + orderList + "'," + (loadGroupCo ? 1 : 0) + "," + 		(loadAll ? 1 : 0) + ")";

	SqlTable myTable = CawDs.getResult(sql);
	if (myTable != null && myTable.size() > 0) {
		SqlTableLib.append(retTable, myTable);
	}
}
```



## FinanceDataHelper

### Purpose

Used to extend AR invoice.

<br/>

### Function  `updateArInvoiceRemain`

```java
public default void updateArInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
}
```

**Description**

Used to load the extended AR invoice  balance amount, such as [XXXX AR Invoice]

**Parameters**

| 名称         | 类型         | 说明                                       |
| ---------- | ---------- | ---------------------------------------- |
| retTable   | `SqlTable` | The invoice balance amount data          |
| beId       | `long`     | The business entity id                   |
| uId        | `long`     | User id                                  |
| AIType     | `String`   | Debtor type                              |
| AIId       | `long`     | Debtor id                                |
| moduleFrom | `String`   | The transaction type which load the data |
| sourceId   | `long`     | The id of the transaction which load the data |
| sTranId    | `long`     | AR Invoice id                            |
| multiId    | `long`     | [Multiple Receipt] id                    |
| sTranType  | `String`   | AR Invoice type                          |
| tDate      | `String`   | As at date                               |



### **Example**

When loading the balance amount of [XXXX AR Invoice], extended as follows

```java
@Override
public default void updateArInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
		String sql = "CALL l_xxxx_arRemain (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", '" + moduleFrom + "', " + sourceId + ", '" + sTranType + "', " + sTranId + "," 		+ multiRecId + ",'" + tDate + "')";	

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### Function  `updateApInvoiceRemain`

```java
public default void updateApInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
}
```

**Description**

Used to load the extended AP invoice  balance amount, such as [XXXX AP Invoice]

**Parameters**

| 名称         | 类型         | 说明                                       |
| ---------- | ---------- | ---------------------------------------- |
| retTable   | `SqlTable` | The invoice balance amount data          |
| beId       | `long`     | The business entity id                   |
| uId        | `long`     | User id                                  |
| AIType     | `String`   | Creditor type                            |
| AIId       | `long`     | Creditor id                              |
| moduleFrom | `String`   | The transaction type which load the data |
| sourceId   | `long`     | The id of the transaction which load the data |
| sTranId    | `long`     | AP Invoice id                            |
| multiId    | `long`     | [Multiple Payment] id                    |
| sTranType  | `String`   | AP Invoice type                          |
| tDate      | `String`   | As at date                               |



### **Example**

When loading the balance amount of [XXXX AP Invoice], extended as follows

```java
@Override
public default void updateApInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
		String sql = "CALL l_xxxx_apRemain (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", '" + moduleFrom + "', " + sourceId + ", '" + sTranType + "', " + sTranId + "," 		+ multiRecId + ",'" + tDate + "')";	

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### Function  `appendArOsInvoice`

```java
public default void appendArOsInvoice(SqlTable retTable, long beId, long uId, String AIType, 		long AIId, long recregId, long multiRecId, String sDate, String eDate, String sDDate, String 	 eDDate, String sStaff, String eStaff, int loadCrNote, String invList, String sTranType, 		String moduleFrom, boolean loadGroupCo) {
}
```

**Description**

Used to load the extended AR invoice outstanding invoice, such as [XXXX AR Invoice]

**Parameters**

| 名称          | 类型         | 说明                                       |
| ----------- | ---------- | ---------------------------------------- |
| retTable    | `SqlTable` | Outstanding AR Invoice data              |
| beId        | `long`     | The business entity id                   |
| uId         | `long`     | User id                                  |
| AIType      | `String`   | Debtor type                              |
| AIId        | `long`     | Debtor id                                |
| recregId    | `long`     | The id of the transaction which load the data |
| multiRecId  | `long`     | [Multiple Receipt] id                    |
| sDate       | `String`   | Start date                               |
| eDate       | `String`   | End date                                 |
| sDDate      | `String`   | Start due date                           |
| eDDate      | `String`   | End due date                             |
| sStaff      | `String`   | Start staff code                         |
| eStaff      | `String`   | End staff code                           |
| loadCrNote  | `int`      | Load with no balance                     |
| invList     | `String`   | The invoice list which need to load (load all when empty) |
| sTranType   | `String`   | AR invoice type                          |
| moduleFrom  | `String`   | The transaction type which load the data |
| loadGroupCo | `boolean`  | Load group company data                  |



### **Example**

When loading the outstanding amount of [XXXX AR Invoice], extended as follows

```java
@Override
public void appendArOsInvoice(SqlTable retTable, long beId, long uId, String AIType, long AIId, 	long recregId, long multiRecId, String sDate, String eDate, String sDDate, String eDDate, 		String sStaff, String eStaff, int loadCrNote, String invList, String sTranType, String 			moduleFrom, boolean loadGroupCo) {
		String sql = "CALL l_xxxx_napbal (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", " + payRegId + ", " + multiPayId + ", '" + sDate + "','" + eDate + "','" + 			sDDate + "','" + eDDate + "','" + sStaff + "','" + eStaff + "'," + loadDbNote + ", '" + 		invList + "','" + sTranType + "', '" + moduleFrom + "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### Function  `appendApOsInvoice`

```java
public default void appendApOsInvoice(SqlTable retTable, long beId, long uId, String AIType, 		long AIId, long payRegId, long multiPayId, String sDate, String eDate, String sDDate, String 	eDDate, String sStaff, String eStaff, int loadDbNote, String invList, String sTranType, 		String moduleFrom, boolean loadGroupCo) {
}
```

**Description**

Used to load the extended AP invoice outstanding invoice, such as [XXXX AP Invoice]

**Parameters**

| 名称          | 类型         | 说明                                       |
| ----------- | ---------- | ---------------------------------------- |
| retTable    | `SqlTable` | Outstanding AR Invoice data              |
| beId        | `long`     | The business entity id                   |
| uId         | `long`     | User id                                  |
| AIType      | `String`   | Creditor type                            |
| AIId        | `long`     | Creditor id                              |
| payRegId    | `long`     | The id of the transaction which load the data |
| multiPayId  | `long`     | [Multiple Payment] id                    |
| sDate       | `String`   | Start date                               |
| eDate       | `String`   | End date                                 |
| sDDate      | `String`   | Start due date                           |
| eDDate      | `String`   | End due date                             |
| sStaff      | `String`   | Start staff code                         |
| eStaff      | `String`   | End staff code                           |
| loadDbNote  | `int`      | Load with no balance                     |
| invList     | `String`   | The invoice list which need to load (load all when empty) |
| sTranType   | `String`   | AP invoice type                          |
| moduleFrom  | `String`   | The transaction type which load the data |
| loadGroupCo | `boolean`  | Load group company data                  |



### **Example**

When loading the outstanding amount of [XXXX AP Invoice], extended as follows

```java
@Override
public void appendApOsInvoice(SqlTable retTable, long beId, long uId, String AIType, long AIId, 	long payRegId, long multiPayId, String sDate, String eDate, String sDDate, String eDDate, 		String sStaff, String eStaff, int loadDbNote, String invList, String sTranType, String 			moduleFrom, boolean loadGroupCo) {
		String sql = "CALL l_prodac_napbal (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", " + payRegId + ", " + multiPayId + ", '" + sDate + "','" + eDate + "','" + 			sDDate + "','" + eDDate + "','" + sStaff + "','" + eStaff + "'," + loadDbNote + ", '" + 		invList + "','" + sTranType + "', '" + moduleFrom + "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```

